
# ბილეთი 2
### 1) შექმენით პროგრამა, რომელიც გააკეთებს ვექტორს განაცხადშივე შეავსებს მას რამდენიმე სტრინგით (5 ან 6 მაინც) ამ ვექტორისგან შექმნის გროვას და დაბეჭდავს მის შიგთავსს. შემდეგ დაამატებს გროვაში კიდევ ორ ელემენტს.მოიყვანეთ მაგალითი გროვაში ელემენტის ჩამატების ალგორითმის ფსევდოკოდი ან კოდი და მისი სისწრაფის შეფასება (დამტკიცების გარეშე)

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
int main(){
    vector<string> v = {"banana", "apple", "cherry", "fig", "grape"
};
make_heap(v.begin(), v.end());
for(auto el : v)
{
    cout << el << " ";
}
cout << endl;
v.push_back("car");
v.push_back("house");
/*INSERT(heap, value);
    Append value to the end of heap
    i <- last index(heap.size - 1)
    WHILE i > 0 AND heap[i] > heap[parent(i)]:
        SWAP heap[i] with heap[parent i]
        i <- parent(i)*/
```
### 2) უპასუხეთ შემდეგ კითხვებს: მოიყვანეთ ძებნის ორობითი ხის განმარტება

```
ძებნის ორობით ხე არის მონაცემთა სტრუქტურა რომელიც გამოიყნება კომპიუტერულ მეცნიერებაში მონაცემთა დასახარისხებლად, შესანახად. ორობით საძიებო ხის თითოეულ კვანძს ჰყავს მაქსიმუმ ორი შვილი, მარცხენა და მარჯვენა. მარცხენა შვილი შეიცავს მშობელ კვანძზე ნაკლებ მნიშვნელობას, ხოლო მარჯვენა შვილი შეიცავს მშობელ კვანძზე მეტ მნიშვნელობებს. ის იერარქიული სტრუქტურა იძლევა ხეში შენახულ მონაცემებზე ეფექტური ძიების ჩასმის და წაშლის ოპერაციები.
```
### დახატეთ ძებინის ორობითი ხე რომელის კვანძებში მისამართებით a1, ... , a6 ჩაწერილია გასაღებები 55, 77, 60, 35, 40, 41; კვანძებს მიუთითეთ შესაბამისი მისამართი.

```
    55(a1)
  /      \
35(a4)   77(a2)
   \      /    
 40(a5)  60(a3)
      \
       41(a6)
```
### როგორ განიმარტება ძებნის ორობითი ხის სიმაღლე? როგორია ამ ხის სიმაღლე? 

```
ძებნის ორობითი ხის სიმაღლე განისაზღვრება, კვანძებთა შორის არსებული მაქსიმალური დონით.
ამ ხის სიმაღლეა - 3
```
### რისი ტოლია left(p(p(a5))) და left(p(a5)) მისამართები?

```
left(p(p(a5))) - 35(a4)
left(p(a5)) - NULL/none
```
### რისი ტოლია a6-ის მომდევნო მისამართი? a1 - ის მომდევნო მისამართი?

```
როგორც ვხედავთ a6 - ის მომდევნო მისამართი ხეში არ არსებობს, ძებნა ჩვეულებრივად დაიწყება თუმცა საბოლოოდ როცა დავადგენთ, რომ მიზნის მნიშვნელობა არ არსებობს ხეში ძებნა სრულდება და დააბრუნებს null/None მისამართს.
```
### მოიყვანეთ პროგრამის ფრაგმენტი, რომელიც შექმნის სიმრავლის (ხეს), ჩატარებს მასში მითითებულ გასაღებებს, მოძებნის 40-ს და დაბეჭდავს ძებნის შედეგს.

```cpp
hello
   
```
### დახატეთ ძებნის დალაგებული ხე, რომლის კვანძებში მისამართებით a1, ..., a6 ჩაწერილია გასაღებები 55, 77, 60, 35, 40, 41 კვანძებს მიუთითეთ შესაბამისი მისამართი. 

```
		 55(a1)
		/       \
	35(a4)      77(a2)
		\	      /
		40(a5)	60(a3)
            \
            41(a6)
``` 

### რისი ტოლია a1 კვანძის რანგი (ანუ მისი გასაღები სიდიდით რომელია ხეში) და რატომ

```
 hello
```
### რომელი კვანძები არის სიდიდით მეორე და სიდიდით მეხუთე?

```
hello
```
### მოიყვანეთ რომელიმე ერთი ალგორითმის კოდი ან ფსევდო კოდი, რომელიც მუშაობს სიმაღლის პროპორციულ დროში.

```cpp
// ჩასმის ფუნქცია
 void insert(int data) {
    if (this->root == null) {
      this->root = new node(data);
      return;
    }

    node *current = this->root;
    while (current != null) {
      if (data <= current->data && current->left == null) {
        current->left = new node(data);
        return;
      }

      if (data <= current->data) {
        current = current->left;
        continue;
      }

      if (current->right == null) {
        current->right = new node(data);
        return;
      }

      current = current->right;
    }
  }

// ძებნის ფუნქცია
  bool search(int data) {
    if (this->root == null) {
      return false;
    }

    if (data == this->root->data) {
      return true;
    }

    node *current = this->root;

    while (current != null) {
      if (data == current->data) {
        return true;
      }

      if (data <= current->data) {
        current = current->left;
      } else {
        current = current->right;
      }
    }

    return false;
  }

```
### 3) ღია მისამართებით ჰეშირებისთვის (open addressing) მოიყვანეთ ჩამატების (insert) ფუნქციის ფსევდო კოდი. წრფივი გადასინჯვებით ჰეშირებისას, რა სახე აქვს H(k,i) ფუნქციას? H(k,i) ფუნქციაში აიღეთ: h(k) - k და ცარიელ 9 ელემენტიან ცხრილში ჩაამატეთ გასაღები 18, 28, 55 ყოველი გასაღების ჩამატებისას, აჩვენეთ როგორ მუშაობს insert ფუნქცია.

```
Insert(T, k):
    for i = 0 to m - 1:
        j = (h(k) + i) mod m
        if T[j] is EMPTY:
            T[j] = k
            return j
    error "Hash table overflow"


ცარიელი ცხრილი:
T = [ _ , _ , _ , _ , _ , _ , _ , _ , _ ]

1. Insert(18):
- h(18) = 18
- H(18, 0) = (18 + 0) mod 9 = 0
- T[0] ცარიელია → ჩასვამთ 18
შედეგი:  
T = [ 18 , _ , _ , _ , _ , _ , _ , _ , _ ]

2. Insert(28):
- h(28) = 28  
- H(28, 0) = (28 + 0) mod 9 = 1  
- T[1] ცარიელია → ჩასვამთ 28
შედეგი:  
T = [ 18 , 28 , _ , _ , _ , _ , _ , _ , _ ]

2. Insert(55):
- h(55) = 55   
- H(55, 0) = (55 + 0) mod 9 = 1 → დაკავებულია (28)   
- H(55, 1) = (55 + 1) mod 9 = 2 → ცარიელია → ჩასვამთ 55
შედეგი:  
T = [ 18 , 28 , 55 , _ , _ , _ , _ , _ , _ ]
```
### მოიყვანეთ პროგრამული კოდის ფრაგმენტი, რომელშიც კეთდება განაცხადი დაუხარისხებელი სიმრავლის ობიექტზე. მოხდება 18, 28, 55 გასაღებების ჩამატება, ელემენტების 55 და 88 მოძებნა და წაშლა.

```cpp
#include <iostream>
#include <unordered_set>

int main() {
    std::unordered_set<int> mySet;

    mySet.insert(18);
    std::cout << mySet.size() << std::endl;

    mySet.insert(28);
    std::cout << mySet.size() << std::endl;

    mySet.insert(55);
    std::cout << mySet.size() << std::endl;


    mySet.insert(18);
    std::cout<< mySet.size() << std::endl;
    
    if (mySet.count(55)) {
        std::cout << "found: 55" << std::endl;
    } else {
        std::cout << "not fount: 55" << std::endl;
    }

    if (mySet.find(88) != mySet.end()) {
        std::cout << "found: 88" << std::endl;
    } else {
        std::cout << "not found: 88" << std::endl;
    }
    
    size_t erased_count_55 = mySet.erase(55);
    if (erased_count_55 > 0) {
        std::cout << "deleted: 55. სიმრავლის ზომა: " << mySet.size() << std::endl;
    } else {
        std::cout << "not found 55 for deletion" <<std::endl;
    }

    size_t erased_count_88 = mySet.erase(88);
    if (erased_count_88 > 0) {
        std::cout << "deleted: 88" << std::endl;
    } else {
        std::cout << "not found 88 for deletion" << std::endl;
    }
    for (int num : mySet) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
}
```
### 4) გააკეთეთ განაცხადი სიმრავლის (set) ობიექტზე დს განაცხადის გაკეთების მომენტშივე ჩააგდეთ მასში რამდენიმე ნამდვილი რიცხვი. შემდეგ, გაიგეთ კონტეინერში მოთავსებული უარყოფითი რიცხვების რაოდენობა და დაბეჭდეთ იგი. დაბეჭდეთ კონტეინერის უდიდესი და მისი წინა ელემენტები.

```cpp
#include <algorithm>
#include <iostream>
#include <set>
using namespace std;

int main() {
  set<int> s = {2, 5, 9, 10, 55, -10};

  int negatives = count_if(s.begin(), s.end(), [](int a) { return a < 0; });
  cout << "Negative numbers in Set: " << negatives << endl;

  cout << "Set max element: " << *s.rbegin()
       << "and previous element of max: " << *(--s.rbegin()) << endl;
}
```
### 5) მოცემულია მთელი არაუარყოფითი რიცხვების ვექტორი {3, 2, 1, 2, 3, 4, 5, 1} დაახარისხეთ იგი გადათვლის (counting sort) ალგორითმით და აჩვენეთ ბიჯების მიხედვით როგორ იცვლება დამხმარე c ვექტორი და საბოლოო b(n) ვექტორი.

```cpp
hello
```
### 6) გროვის აგების ალგორითმის ფსევდოკოდი ან კოდი, მისი სისწრაფის შეფასება დამტკიცების გარეშე

```cpp
hello
```
### ძებნის ორობითი ხე. ხის შემოვლის, ძებნის, მინიმუმის და მაქსიმუმის მოძებნის ალგორითმები. მათი კორექტულობის საკითხი.

```cpp
hello
```

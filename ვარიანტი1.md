# ბილეთი 1
### 1) შექმენით პროგრამა რომელიც გააკეთებს ვექტორს, განაცხადშივე შეავსებს მას რამდენიმე მთელი რიცხვით (5 ან 6 მაინც ამ ვექტორისგან შექმნის გროვას და დაბეჭდავს მის შიგთავსს. შემდეგ დაამატებს გროვაში კიდევ სამ ელემენტს. მოიყვანეთ გროვაში ელემენტის ჩამატების ალგორითმის ფსევდოკოდი ან კოდი და მისი სისწრაფის შეფასება. 
```cpp
#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;
int main() {
  vector<int> v = {6, 69, 4, 8, 16, 17, 26};
  make_heap(v.begin(), v.end());
  for (auto e : v) {
    cout << e << '\t';
  }
  cout << '\n';
  v.push_back(45);
  push_heap(v.begin(), v.end());
  v.push_back(38);
  push_heap(v.begin(), v.end());
  v.push_back(10);
  push_heap (v.begin(), v.end());
  for (auto e : v) {
    cout << e << '\t';
  }
}

template <typename T>
void binary_heap<T>::insert(const T& data) {
    if (root == nullptr) {
        root = new node<T>(data);
        return;
    }
    queue<node<T>*> q;
    q.push(root);
    while (!q.empty()) {
        node<T>* temp = q.front();
        q.pop();
        if (temp->left == nullptr) {
            temp->left = new node<T>(data);
            last = temp->left;
            heapify_tree(root);
            return;
        } else if (temp->right == nullptr) {
            temp -> right = new node<T>(data)
            last = temp->right;
            heapify_tree(root);
            return;
        } else{q.push(temp->left);
            q.push(temp->right);}
    }
template<typename T>
void binary_heap<T>::heapify_subtree
(node<T> * subtree){
    if (subtree == nullptr) {
        return;
    }
    while(true) {
        node<T> * max = subtree;
         if(subtree->left != nullptr && subtree->M_data <= subtree->left->M_data) {
             max = subtree->left;
         }
         if(subtree->right != nullptr && subtree->M_data <= subtree->right->M_data) {
             max = subtree->right;
         }
        if(max != subtree) {
            swap(subtree->M_data, max->M_data);
            subtree = max;}
        else{
            break;}}
        }
```

```
          69
        /   \
      16     26
     /  \    / \
    8    6  17  4
   /
  48
```
```
Average O(1) - თუ არსებობს ელემენტი შექმენი ელემენტი
Worst - Case O(log n) - თუ უკვე არსებობს ჩასვი პირველ ცარიელ ადგილას Heapify()

სისწრაფის შეფასება
ინსერტი - O(1)  O(Log n)
find-min - O(1)  O(1)
delete-min - O(Log n) O(Log n)
decrease - key - O(Log n) O(Log n)
მერჯი - O(n) O(n)
parent - (i - 1) / 2
```
### 2) უპასუხეთ შემდეგ კითხვებს: მოიყვანეთ ძებნის ორობითი ხის განმარტება: 

```
ძებნის ორობით ხე არის მონაცემთა სტრუქტურა რომელიც გამოიყნება კომპიუტერულ მეცნიერებაში მონაცემთა დასახარისხებლად, შესანახად. ორობით საძიებო ხის თითოეულ კვანძს ჰყავს მაქსიმუმ ორი შვილი, მარცხენა და მარჯვენა. მარცხენა შვილი შეიცავს მშობელ კვანძზე ნაკლებ მნიშვნელობას, ხოლო მარჯვენა შვილი შეიცავს მშობელ კვანძზე მეტ მნიშვნელობებს. ის იერარქიული სტრუქტურა იძლევა ხეში შენახულ მონაცემებზე ეფექტური ძიების ჩასმის და წაშლის ოპერაციები.
```
___
### დახატეთ ძებინის ორობითი ხე რომელის კვანძებში მისამართებით a1, ... , a6 ჩაწერილია გასაღებები 55, 77, 45, 56, 46, 80; კვანძებს მიუთითეთ შესაბამისი მისამართი.
```
    55(a1)
  /      \
43(a3)   77(a2)
  \       /    \
46(a5)  56(a4)  80(a6)
```
### როგორ განიმარტება ძებნის ორობითი ხის სიმაღლე? როგორია ამ ხის სიმაღლე? 
```
ძებნის ორობითი ხის სიმაღლე განისაზღვრება, კვანძებთა შორის არსებული მაქსიმალური დონით. ამ ხის სიმაღლეა 2
``` 
რისი ტოლია left(p(p(a6))) და left(p(a6)) მისართები?
```
1) a3 - 45
2) a4 - 56
```
### რისი ტოლია a4-ის მომდევნო მისამართი? a1 - ის მომდევნო მისამართი?

```
როგორც ვხედავთ a4 - ის მომდევნო მისამართი ხეში არ არსებობს, ძებნა ჩვეულებრივად დაიწყება თუმცა საბოლოოდ როცა დავადგენთ, რომ მიზნის მნიშვნელობა არ არსებობს ხეში ძებნა სრულდება და დააბრუნებს null/None მისამართს.
in - order - traversal - 56 ანუ a4
level - order - traversal - 45 ანუ a3
```
### მოიყვანეთ პროგრამის ფრაგმენტი, რომელიც შექმნის სიმრავლის (ხეს), ჩატარებს მასში მითითებულ გასაღებებს, მოძებნის 70-ს და დაბეჭდავს ძებნის შედეგს.

```cpp
#include <iostream>
#include <set>

int main() {
    std::set<int> s;

    s.insert(10);
    s.insert(25);
    s.insert(70);
    s.insert(5);
    s.insert(100);

    if (s.find(70) != s.end()) {
        std::cout << "70 found\n";
    } else {
        std::cout << "70 not found\n";
    }

    return 0;
}
```
### დახატეთ ძწბნის დალაგებული ხე, რომლის კვანძებში მისამართებით a1, ..., a6 ჩაწერილია გასაღებები 55, 77, 45, 56, 46, 80 კვანძებს მიუთითეთ შესაბამისი მისამართი.

```
    55(a1)
  /       \
45(a3)     77(a2)
   \        /    \
   46(a5)  56(a4) 80(a6)
```
### რისი ტოლია a1 კვანძის რანგი (ანუ მისი გასაღები სიდიდით რომელია ხეში) და რატომ 

```
a1 - ის რანგი = 2; რადგან მის ქვეშ ყველაზე გრძელი გზა შედგება 2 შვილისგან.
```
### რომელი კვანძები არის სიდიდით მეორე და სიდიდით მეოთხე?
```
მეორე - 77
მეოთხე - 55
```
### მოიყვანეთ რომელიმე ერთი ალგორითმის კოდი ან ფსევდო კოდი, რომელიც მუშაობს სიმაღლის პროპორციულ დროში.
```cpp
#include <iostream>
using namespace std;

int main() {
    int a[] = {3, 5, 7, 9, 11};
    int n = 5, x = 7;

    for (int i = 0; i < n; i++) {
        if (a[i] == x) {
            cout << "Found at index " << i;
            return 0;
        }
    }

    cout << "Not found";
    return 0;
}
```
### 3) ღია მისამართებით ჰეშირებისთვის (open addressing) მოიყვანეთ ჩამატების (insert) ფუნქციის ფსევდო კოდი. წრფივი გადასინჯვებით ჰეშირებისას, რა სახე აქვს H(k,i) ჰეშ-ფუნქციას, სადაც k გასაღებია, i ცდის ნომერი? ვთქვათ, შემდეგ ჰეშ-ცხრილი მიღებულია წრფივი გადასინჯვებით, როდესაც ჰეშ-ფუნქცია ტოლია თავისი გასაღების ანუ n(k) - k

### 0|1|2|3|4|5|6|7|8|9|10|

### 0|0|0|0|4|26|0|0|0|0|10|

### აჩვენეთ თუ როგორ მოხდება ამ ცხრილში 42 ს 97 გასაღებების ჩამატება.
```cpp
Function Insert(key, value):
    index = this.Hash(key) // Calculate the initial hash index
    initial_index = index  // Store the initial index to detect a full table

    Loop indefinitely:
        If this.table[index] is NULL (empty):
            this.table[index] = (key, value) // Insert the element
            Return true (successfully inserted)
        If this.table[index] is DUMMY_NODE (deleted but available):
            // This slot is available for insertion because it was previously deleted
            this.table[index] = (key, value)
            Return true (successfully inserted)
        If this.table[index].key == key:
            this.table[index].value = value // Key already exists, update its value
            Return true
        
        index = (index + 1) % this.size // Move to the next index (linear probing logic)

        If index == initial_index:
            Return false (table is full, cannot insert)
```
### მოიყვანეთ პროგრამული კოდის ფრაგმენტი, რომელშიც კეთდება განაცხადი დაუხარისხებელი სიმრავლის ობიექტზე, მოხდება იგივე გასაღებების ჩამატება რაც წერია ცხრილში, შემდეგ 42 და 97-ის დამატება, შემდეგ 97-ის მოძებნა და წაშლა.
```cpp
hello
```
### 4) გააკეთეთ განაცხადი სიმრავლის (set) ობიექტზე და განაცხადის გაკეთების მომენტშივე ჩააგდეთ მასში რამდენიმე ნამდვილლი რიცხვი. შემდეგ იანგარიშეთ კონტეინერში მოთავსებული ელემენტების ნამრავლი და დაბეჭდეთ იგი. დაბეჭდეთ კონტეინერის უდიდესი და უმცირესი ელემენტები.
```cpp
#include <iostream>
#include <set>

int main() {
    std::set<double> s;
//shenaxva
    s.insert(5,6);
    s.insert(4,3);
    s.insert(8,9);
    s.insert(26,6);
//namravli
    double namravli = 1;
      for(auto e:s){
          namravli *= e;
      }
      cout << namravli << '\n';
//minimaluri
cout << *s.begin()<<'\n';
//maximaluri
cout << *s.rbegin() << '\n';
}
```
### 5) მოცემულია მთელი არაუარყოფითი რიცხვების ვექტორი (0, 2, 1, 2, 3, 0, 5, 3) დაახასიათეთ იგი გადათვლის (CountingSort) ალგორითმით და აჩვენეთ ბიჭების მიხედვით როგორ იცვლება დამხმარე c ვექტორი და საბოლოო b(n) ვექტორი.

```
**_ბიჯი ერთი:_** შევქმნით დამხმარე C ვექტორს , რომლის ზომა იქნება max_val−min_val+1. ამ შემთხვევაში, 5−0+1=6. C ვექტორის ინდექსები იქნება 0-დან 5-ის ჩათვლით, რაც შეესაბამება ჩვენი რიცხვების დიაპაზონს. თავდაპირველად ყველა მნიშვნელობა ნული იქნება.

**_ბიჯი ორი:_** ეხება უკვე საწყისი ვექტორიდან ელემენტების დათვლას C ვექტორში.
ახლა გავივლით **A** ვექტორს და თითოეული ელემენტისთვის გავზრდით C ვექტორის შესაბამისი ინდექსის მნიშვნელობას ერთით. რადგან ჩვენი min_val არის 0, არ გვჭირდება ოფსეტის გამოკლება (თუ min_val მაგალითად 7 ყოფილიყო, 7-იანის დასათვლელად C[7−7]=C[0]-ს გამოვიყენებდით).

|            |                     |               |
| ---------- | ------------------- | ------------- |
| A ელემენტი | C ვექტორის ცვლილება | C ვექტორი     |
| A[0]=0     | C[0]++              | [1,0,0,0,0,0] |
| A[1]=2     | C[2]++              | [1,0,1,0,0,0] |
| A[2]=1     | C[1]++              | [1,1,1,0,0,0] |
| A[3]=2     | C[2]++              | [1,1,2,0,0,0] |
| A[4]=3     | C[3]++              | [1,1,2,1,0,0] |
| A[5]=0     | C[0]++              | [2,1,2,1,0,0] |
| A[6]=5     | C[5]++              | [2,1,2,1,0,1] |
| A[7]=3     | C[3]++              | [2,1,2,2,0,1] |

**C ვექტორი მეორე ნაბიჯის ბოლოს:** C=[2,1,2,2,0,1] (ეს ნიშნავს: 0 გვხვდება 2-ჯერ, 1 გვხვდება 1-ხელ, 2 გვხვდება 2-ჯერ, 3 გვხვდება 2-ჯერ, 4 გვხვდება 0-ჯერ, 5 გვხვდება 1-ხელ).

**_ნაბიჯი 3:_**
ახლა შევცვლით C ვექტორს ისე, რომ C[i] შეიცავდეს იმ ელემენტების რაოდენობას, რომლებიც i-ზე ნაკლები ან i-ის ტოლია. ეს დაგვეხმარება ელემენტის საბოლოო პოზიციის განსაზღვრაში.

|           |                    |                    |                     |     |
| --------- | ------------------ | ------------------ | ------------------- | --- |
| C ინდექსი | წინა C მნიშვნელობა | გამოთვლა           | ახალი C მნიშვნელობა |     |
| C[0]      | 2                  | - (არ იცვლება)     | 2                   |     |
| C[1]      | 1                  | C[1]=C[1]+C[0]=1+2 | 3                   |     |
| C[2]      | 2                  | C[2]=C[2]+C[1]=2+3 | 5                   |     |
| C[3]      | 2                  | C[3]=C[3]+C[2]=2+5 | 7                   |     |
| C[4]      | 0                  | C[4]=C[4]+C[3]=0+7 | 7                   |     |
| C[5]      | 1                  | C[5]=C[5]+C[4]=1+7 | 8                   |     |

**C ვექტორი მესამე ბიჯის ბოლოს:** C=[2,3,5,7,7,8]

**_ბიჯი 4:_**
შევქმნით საბოლოო ვექტორს B, რომლის ზომა იქნება n (ანუ 8). ახლა გავივლით **A** ვექტორს **ბოლოდან დასაწყისისკენ** (ეს მნიშვნელოვანია სტაბილურობისთვის!) და C ვექტორის დახმარებით თითოეულ ელემენტს მის სწორ პოზიციაზე დავსვამთ B ვექტორში. ყოველი განთავსების შემდეგ, ვამცირებთ შესაბამის მრიცხველს C ვექტორში.
B=[_,_,_,_,_,_,_,_]

|           |                  |                   |                        |                     |                     |     |
| --------- | ---------------- | ----------------- | ---------------------- | ------------------- | ------------------- | --- |
| A ინდექსი | A[i] მნიშვნელობა | C[A[i]] (პოზიცია) | B პოზიცია ( C[A[i]]−1) | B ვექტორის ცვლილება | C ვექტორის ცვლილება |     |
| A[7]=3    | 3                | C[3]=7            | B[6]                   | [_,_,_,_,_,_,3,_]   | C[3] ხდება 6        |     |
| A[6]=5    | 5                | C[5]=8            | B[7]                   | [_,_,_,_,_,_,3,5]   | C[5] ხდება 7        |     |
| A[5]=0    | 0                | C[0]=2            | B[1]                   | [_,0,_,_,_,_,3,5]   | C[0] ხდება 1        |     |
| A[4]=3    | 3                | C[3]=6            | B[5]                   | [_,0,_,_,_,3,3,5]   | C[3] ხდება 5        |     |
| A[3]=2    | 2                | C[2]=5            | B[4]                   | [_,0,_,_,2,3,3,5]   | C[2] ხდება 4        |     |
| A[2]=1    | 1                | C[1]=3            | B[2]                   | [_,0,1,_,2,3,3,5]   | C[1] ხდება 2        |     |
| A[1]=2    | 2                | C[2]=4            | B[3]                   | [_,0,1,2,2,3,3,5]   | C[2] ხდება 3        |     |
| A[0]=0    | 0                | C[0]=1            | B[0]                   | [0,0,1,2,2,3,3,5]   | C[0] ხდება 0        |     |

**_დალაგებული ვექტორი B=(0,0,1,2,2,3,3,5)_**
```
### 6) ორობითი გროვა: ძირითადი განმარტებები, გროვის ძირითადი მეთოდების აღწერა, გროვის ძირითადი თვისების აღდგენის ალგორითმის ფსევდო კოდი ან კოდი, მისი სისწრაფის შეფასება და ალგორითმის კორექტულობის საკითხი.
```
hello
```
### 7) გადათვლით დახარისხების ალგორითმი, მისი სისწრაფის შეფასება და განხილვა შესაძლო განზოგადებები.
```
counting sort დახარისხების სპეციფიკური ალგორითმია იმიტომ, რომ იგი მხოლოდ და მხოლოდ მთელ რიცხვებს ამუშავებს, ამის ხაეჯზე ეს ითვლება საუკეთესო ალგორითმად ბიჯების თვალსაზრისით. სისწრაფე პროპორციულია დიაპაზონის. ის წრფივ დროში ახარისხებს მონაცემებს მისი მუშაობის სიჩქარეა n. მისი სიჩქარე დამოკიდებულია იმაზე თუ რამდენი ელემენტიც აქვს (რამხელა დიაპაზონიც აქვს კონტეინერს) counting sort - ისთვის საჭიროა დამხმარე კონტეინერი.
```

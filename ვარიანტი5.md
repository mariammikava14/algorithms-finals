 ### 1)  შექმენით პროგრამა რომელიც გააკეთებს ვექტორს, განაცხადშივე შეავსებს მას რამდენიმე მოკლე მთელი რიცხვით (4 ან 5 მაინც) ამ ვექტორისგან შექმნის გროვას და დაბეჭდავს მის შიგთავსს. შემდეგ დაამატებს გროვაში კიდევ სამ ელემენტს. მოიყვანეთ გროვაში ელემენტის ჩამატების ალგორითმის ფსევდოკოდი ან კოდი და მისი სისწრაფის შეფასება.
 ```cpp
hello
```
### 2) უპასუხეთ შემდეგ კითხვებს: მოიყვანეთ ძებნის ორობითი ხის განმარტება: 
```
ძებნის ორობით ხე არის მონაცემთა სტრუქტურა რომელიც გამოიყნება კომპიუტერულ მეცნიერებაში მონაცემთა დასახარისხებლად, შესანახად. ორობით საძიებო ხის თითოეულ კვანძს ჰყავს მაქსიმუმ ორი შვილი, მარცხენა და მარჯვენა. მარცხენა შვილი შეიცავს მშობელ კვანძზე ნაკლებ მნიშვნელობას, ხოლო მარჯვენა შვილი შეიცავს მშობელ კვანძზე მეტ მნიშვნელობებს. ის იერარქიული სტრუქტურა იძლევა ხეში შენახულ მონაცემებზე ეფექტური ძიების ჩასმის და წაშლის ოპერაციები.
```
### დახატეთ ძებინის ორობითი ხე რომელის კვანძებში მისამართებით a1, ... , a6 ჩაწერილია გასაღებები 55, 77, 60, 35, 40, 57; კვანძებს მიუთითეთ შესაბამისი მისამართი.
```
    55(a1)
  /      \
35(a4)   77(a2)
   \      /    
 40(a5) 60(a3)
          /
       57(a6)
```
### 3) ღია მისამართებით ჰეშირებისთვის (open addressing) მოიყვანეთ ჩამატების (insert) ფუნქციის ფსევდო კოდი. წრფივი გადასინჯვებით ჰეშირებისას, რა სახე აქვს H(k,i) ჰეშ-ფუნქციას, H(k,i) ფუნქციაში აიღეთ: h(k) = k და ცარიელ 9 ელემენტიან ცხრილში ჩაამატეთ გასაღებები 20, 30, 57. ყოველი გასაღების ჩქმატებისას, აჩვენეთ როგორ მუშაობს insert ფუნქცია.
### მოიყვანეთ პროგრამული კოდის ფრაგმენტი, რომელშიც კეთდება განაცხადი დაუხარისხებელი სიმრავლის ობიექტზე. მოხდება 20, 30, 57 გასაღებების ჩამატება ელემენტების 30 და 38 მოძებნა და წაშლა.
```cpp
```
### 4) გააკეთეთ განაცხადი სიმრავლის (set) ობიექტზე და განაცხადის გაკეთების მომენტშივე ჩააგდეთ მასში რამდენიმე ნამდვილი რიცხვი. შემდეგ იანგარიშეთ კონტეინერში მოთავსებული ელემენტების ჯამი და დაბეჭდეთ კონტეინერის უდიდესი და მისი წინა ელემენტები.
```cpp
```
### 5) მოცემულია მთელი არაუარყოფითი რიცხვების ვექტორი (4, 2, 1, 2, 3, 4, 5, 3) დაახასიათეთ იგი გადათვლის (CountingSort) ალგორითმით და აჩვენეთ ბიჯების მიხედვით როგორ იცვლება დამხმარე c ვექტორი და საბოლოო b(n) ვექტორი.

```
hello
```
### 6) ჰეშირება: ძირითადი განმარტებები, ჰეშ-ფუნქციები, ღია მისამართებით ჰეშირებაში (იგივე ჩაკეტილი ჰეშირება), წრფივი გადარჩევის და ორმაგი ჰეშირების მეთოდები და მათი კორექტულობის საკითხი.
```
ძირითადი განმარტებები - ჰეშირება არის მეთოდი, რომელიც ყოველ ელემენტს უსაბამებს გარკვეულ ინდექსს (ანუ სადაც უნდა ჩაისვას) ყოველი ელემენტი ინახება სწრაფი წვდომის კონტეინერში (vector, array, deque)
ამ შესანახ/შენახულ ელემენტებს მეორენაირად გასაღებებს ვუწოდებთ.
ჰეშ ფუნქცია - სპეც ფუნცქია რომელიც გასაღებებს ინდექსებს უსაბამებს(ანუ ცხრილში ჩასასმელ ინდექსს) რომლებიც აიხსნება ნულს დამატებული ნატურალური რიცხვი.
ჰეშირებები ორ ეტაპად ხორციელდება. პირვეად ჯერ ჰეშ ფუნქცია იქმნება. შემდეგ ალგორითმი უსაბამებს ელემენტებს ინდექსებს. ხოლო მეორე ეტაპზე ვსვამ m ელემენტიდან ჰეშ-ცხრილში.
ჰეშ მნიშვნელობა - მეორენაირად ჰეშ-კოდი ეწოდება - როცა ჰეშ ფუნქცია აბრუნებს პასუხს, ის ფუნქცია კოდის სახით განისაზღვრება.
ჰეშ ცხრილი - იგულისხმება სწრაფი წვდომის კონტეინერი
კოლიზია - მარტივი ენით რომ ვთქვათ დაჯახება რომელიც ხდება მაშინ როდესაც ორ ან რამდენიმე გასაღებს ერთ ინდექსს ანუ ერთი უჯრა მიენიჭება ჩასასმელად.
ღია მისამართებით ჰეშირება (იგივე ჩაკეტილი ჰეშრება) – როდესაც აქტიური გასაღებების რაოდენობა უფრო ნაკლებია, ვიდრე ჰეშ ცხრილის ელემენტების. ამით ჩვენ გვეცოდინება, რომ ჩვენი აქტიური გასაღებები ჰეშ ცხრილში თავისუფლად მოთავსდება. (ამოტომ ეწოდება ჩაკეტილი ჰეშირება).
ჩასასმელი ელემენტი (ანუ აქტიური გასაღები)  გაიყოფა m – ზე ანუ ჰეშ ცხრილის ზომაზე, გაყოფის შედეგად ნაშთი რაც დაგვრჩება ინდექსს წარმოადგენს.
წრფივი ჰეშირება  - ჩასასმელი ინდექსი გამოითვლება ფორმულით:

h (k) = k%n  

თუ კოლიზია მოხდა, ჩასასმელი წრფივად გადაინაცვლებს თავისუფალ უჯრაში. (გასათვალისწინებელია, რომ წრფივი ჰეშირების დროს ღია მისამართებით ჰეშირების ცნებაც უნდა მოვიშველიოთ)

ორმაგი ჰეშირება: H (k,i) = (h1(k) + ih2(k))%m
სადაც h1 და h2 ორი სხვადასხვა სახის ფუნქციაა.
I – ცდების რაოდენობაა
H  - ითვლის ჩასასმელ ინდექსს, k გასაღებისთვის I – ური ცდისთვის.
ნულოვან ცდაზე პირდაპირ იმ ინდექსს გვაძლევს რასაც %.
```
### 7) ძებნის დალაგებული ხე. განსხვავება ძებნის ორობითი ხისგან. სიდიდით i-ური გასაღების შემცველი კვანძის მისამართის განსაზღვრა და მოცემული კვანძის რიგითი ნომრის განსაზღვრა. ალგორითმების კოდი, კორექტულობის საკითხი.
```cpp
hello
```

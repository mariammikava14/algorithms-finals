# ბილეთი 4
### 1) შექმენით პროგრამა რომელიც გააკეთებს ვექტორს, განაცხადშივე შეავსებს მას რამდენიმე სიმბოლოთი (5 ან 6 მაინც) შემდეგ ამ ვექტორისგან შექმნის გროვას და დაამატებს მას კიდევ ორ სიმბოლოს. მოიყვანეთ გროვაში ელემენტის ჩამატების ალგორითმის ფსევდოკოდი ან კოდი და მისი სისწრაფის შეფასება.
```cpp
hello
```
### 2) უპასუხეთ შემდეგ კითხვებს: მოიყვანეთ ძებნის ორობითი ხის განმარტება: 
ძებნის ორობით ხე არის მონაცემთა სტრუქტურა რომელიც გამოიყნება კომპიუტერულ მეცნიერებაში მონაცემთა დასახარისხებლად, შესანახად. ორობით საძიებო ხის თითოეულ კვანძს ჰყავს მაქსიმუმ ორი შვილი, მარცხენა და მარჯვენა. მარცხენა შვილი შეიცავს მშობელ კვანძზე ნაკლებ მნიშვნელობას, ხოლო მარჯვენა შვილი შეიცავს მშობელ კვანძზე მეტ მნიშვნელობებს. ის იერარქიული სტრუქტურა იძლევა ხეში შენახულ მონაცემებზე ეფექტური ძიების ჩასმის და წაშლის ოპერაციები.
___
### დახატეთ ძებინის ორობითი ხე რომელის კვანძებში მისამართებით a1, ... , a6 ჩაწერილია გასაღებები 55, 77, 60, 35, 40, 61; კვანძებს მიუთითეთ შესაბამისი მისამართი.
```
    55(a1)
  /      \
35(a4)   77(a2)
   \      /    
 40(a5) 60(a3)
            \
             61(a6)
```
___
### როგორ განიმარტება ძებნის ორობითი ხის სიმაღლე? როგორია ამ ხის სიმაღლე?
```
ძებნის ორობითი ხის სიმაღლე განისაზღვრება, კვანძებთა შორის არსებული მაქსიმალური დონით.
ამ ხის სიმაღლეა 3
```
___
რისი ტოლია left(p(p(a6))) და right(p(a6)) მისამართები
```
left(p(p(a6))) - 60(a3)
right(p(a6)) - NULL / none
```
### რისი ტოლია a6-ის მომდევნო მისამართი? a1 - ის მომდევნო მისამართი?

```
როგორც ვხედავთ a6 - ის მომდევნო მისამართი ხეში არ არსებობს, ძებნა ჩვეულებრივად დაიწყება თუმცა საბოლოოდ როცა დავადგენთ, რომ მიზნის მნიშვნელობა არ არსებობს ხეში ძებნა სრულდება და დააბრუნებს null/None მისამართს.
```
es arasworia gadasasworebelia - inorder - traversal - 56 ანუ a4

level - order - traversal - 45 ანუ a3 

### მოიყვანეთ პროგრამის ფრაგმენტი, რომელიც შექმნის სიმრავლის (ხეს), ჩატარებს მასში მითითებულ გასაღებებს, მოძებნის 61-ს და დაბეჭდავს ძებნის შედეგს.
```cpp
hello
```
### დახატეთ ძწბნის დალაგებული ხე, რომლის კვანძებში მისამართებით a1, ..., a6 ჩაწერილია გასაღებები 55, 77, 60, 35, 40, 61; კვანძებს მიუთითეთ შესაბამისი მისამართი.

```
   hello
```
### რისი ტოლია a1 კვანძის რანგი (ანუ მისი გასაღები სიდიდით რომელია ხეში) და რატომ 
```
hello
```
### რომელი კვანძები არის სიდიდით მეორე და სიდიდით მეხუთე?
```
hello
```
### მოიყვანეთ რომელიმე ერთი ალგორითმის კოდი ან ფსევდო კოდი, რომელიც მუშაობს სიმაღლის პროპორციულ დროში.
```
hello
```
### 3) ღია მისამართებით ჰეშირებისთვის (open addressing) მოიყვანეთ ჩამატების (insert) ფუნქციის ფსევდო კოდი. წრფივი გადასინჯვებით ჰეშირებისას, რა სახე აქვს H(k,i) ჰეშ-ფუნქციას, სადაც k გასაღებია, i ცდის ნომერი? ვთქვათ, შემდეგ ჰეშ-ცხრილი მიღებულია წრფივი გადასინჯვებით, როდესაც ჰეშ-ფუნქცია ტოლია თავისი გასაღების ანუ h(k) - k

### 0|1|2|3|4|5|6|7|8|9|10|

### 0|0|0|0|4|26|0|0|0|0|120|

### აჩვენეთ თუ როგორ მოხდება ამ ცხრილში 14 და 25 გასაღებების ჩამატება. მოიყვანეთ პროგრამული კოდის ფრაგმენტი, რომელშიც კეთდება განაცხადი დაუხარისხებელი სიმრავლის ობიექტზე, მოხდება იგივე გასაღებების ჩამატება რაც წერია ცხრილში, შემდეგ 14 და 25-ის დამატება, შემდეგ 25-ის მოძებნა და წაშლა.
```cpp
hello
```
### 4) გააკეთეთ განაცხადი სიმრავლის (set) ობიექტზე და განაცხადის გაკეთების მომენტშივე ჩააგდეთ მასში რამდენიმე მთელი რიცხვი. შემდეგ გაიგეთ კონტეინერში მოთავსებული ლუწი რიცხვების რაოდენობა და დაბეჭდეთ იგი. დაბეჭდეთ კონტეინერის უმცირესი და მისი მომდევნო ელემენტები.
```cpp
```
### 5) მოცემულია მთელი არაუარყოფითი რიცხვების ვექტორი (0, 2, 4, 3, 3, 0, 5, 4) დაახასიათეთ იგი გადათვლის (CountingSort) ალგორითმით და აჩვენეთ ბიჯების მიხედვით როგორ იცვლება დამხმარე c ვექტორი და საბოლოო b(n) ვექტორი.

```
hello
```
### 6) ჰეშირება: ძირითადი განმარტებები, ღია მისამართებით ჰეშირებაში (იგივე ჩაკეტილი ჰეშირება) ელემენტის ჩამატებისას, ძებნის და წაშლის ალგორითმები. მათი კორექტულობის საკითხი.
```
ძირითადი განმარტებები - ჰეშირება არის მეთოდი, რომელიც ყოველ ელემენტს უსაბამებს გარკვეულ ინდექსს (ანუ სადაც უნდა ჩაისვას) ყოველი ელემენტი ინახება სწრაფი წვდომის კონტეინერში (vector, array, deque)
ამ შესანახ/შენახულ ელემენტებს მეორენაირად გასაღებებს ვუწოდებთ.
ჰეშ ფუნქცია - სპეც ფუნცქია რომელიც გასაღებებს ინდექსებს უსაბამებს(ანუ ცხრილში ჩასასმელ ინდექსს) რომლებიც აიხსნება ნულს დამატებული ნატურალური რიცხვი.
ჰეშირებები ორ ეტაპად ხორციელდება. პირვეად ჯერ ჰეშ ფუნქცია იქმნება. შემდეგ ალგორითმი უსაბამებს ელემენტებს ინდექსებს. ხოლო მეორე ეტაპზე ვსვამ m ელემენტიდან ჰეშ-ცხრილში.
ჰეშ მნიშვნელობა - მეორენაირად ჰეშ-კოდი ეწოდება - როცა ჰეშ ფუნქცია აბრუნებს პასუხს, ის ფუნქცია კოდის სახით განისაზღვრება.
ჰეშ ცხრილი - იგულისხმება სწრაფი წვდომის კონტეინერი
კოლიზია - მარტივი ენით რომ ვთქვათ დაჯახება რომელიც ხდება მაშინ როდესაც ორ ან რამდენიმე გასაღებს ერთ ინდექსს ანუ ერთი უჯრა მიენიჭება ჩასასმელად.
ღია მისამართებით ჰეშირება (იგივე ჩაკეტილი
ჰეშრება) – როდესაც აქტიური გასაღებების რაოდენობა უფრო ნაკლებია, ვიდრე ჰეშ ცხრილის ელემენტების. ამით ჩვენ გვეცოდინება, რომ ჩვენი აქტიური გასაღებები ჰეშ ცხრილში თავისუფლად მოთავსდება. (ამოტომ ეწოდება ჩაკეტილი ჰეშირება).
ჩასასმელი ელემენტი (ანუ აქტიური გასაღები)  გაიყოფა m – ზე ანუ ჰეშ ცხრილის ზომაზე, გაყოფის შედეგად ნაშთი რაც დაგვრჩება ინდექსს წარმოადგენს.
ძებნის ალგორითმი (მეორე ნაირად search) – გასათვალისწინებელია, რომ თუ Tj   ცხრილის რომელიმე უჯრაში წერია 0 ეს იმას ნიშნავს, რომ ეგ უჯრა ცარიელია და მასში არც იქამდე ეწერა რაიმე ელემენტი.

წაშლის ალგორითმი -  თუ   Tj   ცხრილის რომელიმე უჯრაში წერია -1 ეს იმას ნიშნავს, რომ იმ უჯრაში ეწერა რაიმე ელემენტი და წაიშალა.

როდესაც Search ალგორითმი ჰეშ ცხრილში ეძებს რაიმე ელემენტს იგი ჯერ მოსაძებნ ელემენტს ყოფს m – ზე (ანუ ჰეშ ცხრილის ზომაზე), შემდეგ გაყოფის შედეგად მიღებულ ნაშთს რასაც მიიღებს, ეგ ნაშთი წარმოადგენს იმ მოსაძებნი ელემენტის სავარაუდო ადგილ სამყოფელს და სწორედ იმ ინდექსიდან იწყებს ძიებას. ძიებისას გვხვდება რამდენიმე სხვადასხვა შემთხვევა

1.	თუ ძიების ალგორითმს უჯრაში 0 დახვდა იგი წყვეტს მუშაობას, ჰეშირების სტრუქტურის გათვალისწინებით.
2.	თუ ძიების ალგორითმს უჯრაში -1 დახვდა იგი არ წყვეტს მუშაობას, ეს იმას ნიშნავს, რომ -1 – ის შემდეგ შესაძლოა ეწეროს სხვა ელემენტებიც.
3.	თუ ძიების ალგორითმს უჯრაში სხვა ელემენტი დახვდა, რომელიც საძიებო ელემენტის ტოლი არ არის, ბუნებრივია ძიების ალგორითმი განაგრძობს მუშაობას.
4.	თუ ძიების ალგორითმს უჯრაში დახვდა ის ელემენტი, რომელსაც ეძებდა და იპოვა, ეს იმას ნიშნავს, რომ ოპერაცია დასრულებულია და იგი ასრულებს მუშაობას.

```
### 7) ძებნის ორობითი ხე. მომდევნო და წინა ელემენტების მისამართის განსაზღვრის ალგორითმი. მისი კორექტულობის საკითხი.
```cpp
hello
```

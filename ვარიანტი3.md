 # ბილეთი 3
### შექმენით პროგრამა რომელიც გააკეთებს ვექტორს, განაცხადშივე შეავსებს მას რამდენიმე ნამდვილი რიცხვით (5 ან 6 მაინც) ამ ვექტორისგან შექმნის გროვას და დაბეჭდავს მის შიგთავსს. შემდეგ დაამატებს გროვაში კიდევ ორ ელემენტს. მოიყვანეთ გროვაში ელემენტის ჩამატების ალგორითმის ფსევდოკოდი ან კოდი და მისი სისწრაფის შეფასება.
```cpp
hello
```
### 2) უპასუხეთ შემდეგ კითხვებს: მოიყვანეთ ძებნის ორობითი ხის განმარტება
ძებნის ორობით ხე არის მონაცემთა სტრუქტურა რომელიც გამოიყნება კომპიუტერულ მეცნიერებაში მონაცემთა დასახარისხებლად, შესანახად. ორობით საძიებო ხის თითოეულ კვანძს ჰყავს მაქსიმუმ ორი შვილი, მარცხენა და მარჯვენა. მარცხენა შვილი შეიცავს მშობელ კვანძზე ნაკლებ მნიშვნელობას, ხოლო მარჯვენა შვილი შეიცავს მშობელ კვანძზე მეტ მნიშვნელობებს. ის იერარქიული სტრუქტურა იძლევა ხეში შენახულ მონაცემებზე ეფექტური ძიების ჩასმის და წაშლის ოპერაციები.
___
### დახატეთ ძებინის ორობითი ხე რომელის კვანძებში მისამართებით a1, ... , a6 ჩაწერილია გასაღებები 55, 77, 45, 16, 46, 80; კვანძებს მიუთითეთ შესაბამისი მისამართი.
```
    55(a1)
  /      \
45(a3)   77(a2)
 /    \       \
16(a4) 46(a5)  80(a6)

```
### როგორ განიმარტება ძებნის ორობითი ხის სიმაღლე? როგორია ამ ხის სიმაღლე? 
ძებნის ორობითი ხის სიმაღლე განისაზღვრება, კვანძებთა შორის არსებული მაქსიმალური დონით.

ამ ხის სიმაღლეა - 3
### რისი ტოლია left(p(p(a5))) და right(p(p(a5))) მისამართები?
```
left(p(p(a5))) = 45(a3)
right(p(p(a5))) = 77(a2)
```
### რისი ტოლია a5-ის მომდევნო მისამართი? a1 - ის მომდევნო მისამართი?
```
hello
```
###  მოიყვანეთ პროგრამის ფრაგმენტი, რომელიც შექმნის სიმრავლის (ხეს), ჩატარებს მასში მითითებულ გასაღებებს, მოძებნის 80-ს და დაბეჭდავს ძებნის შედეგს.
```
hello
```
### დახატეთ ძებნის დალაგებული ხე, რომლის კვანძებში მისამართებით a1, ..., a6 ჩაწერილია გასაღებები 55, 77, 45, 16, 46, 80 კვანძებს მიუთითეთ შესაბამისი მისამართი. 
```
 hello
```
### რისი ტოლია a1 კვანძის რანგი (ანუ მისი გასაღები სიდიდით რომელია ხეში) და რატომ
```
 hello
```
### რომელი კვანძები არის სიდიდით მესამე და სიდიდით მეხუთე?
```
hello
```
### მოიყვანეთ რომელიმე ერთი ალგორითმის კოდი ან ფსევდო კოდი, რომელიც მუშაობს სიმაღლის პროპორციულ დროში.
```
hello
```
### 3) ღია მისამართებით ჰეშირებისთვის (open addressing) მოიყვანეთ ჩამატების (insert) ფუნქციის ფსევდო კოდი. წრფივი გადასინჯვებით ჰეშირებისას, რა სახე აქვს H(k,i) ჰეშ-ფუნქციას? სადაც k გასაღებია, i ცდის ნომერი? ვთქვათ, შემდეგ ჰეშ-ცხრილი მიღებულია წრფივი გადასინჯვებით, როდესაც ჰეშ-ფუნქცია ტოლია თავისი გასაღების ანუ h(k) - k
0|1|2|3|4|5|6|7|8|9|10|
0|0|0|0|4|26|0|0|0|0|10|
აჩვენეთ თუ როგორ მოხდება ამ ცხრილში 17 და 26-ის დამატება? 
მოიყვანეთ პროგრამული კოდის ფრაგმენტი, რომელშიც კეთდება განაცხადი დაუხარისხებელი სიმრავლის ობიექტზე. მოხდება იგივე გასაღებების ჩამატება, რაც წერია ცხრილში, შემდეგ 17 და 26-ის დამატება, შემდეგ 97-ის მოძებნა და წაშლა.
```
hello
```
### 4) გააკეთეთ განაცხადი სიმრავლის (set) ობიექტზე დს განაცხადის გაკეთების მომენტშივე ჩააგდეთ მასში რამდენიმე მთელი რიცხვი. შემდეგ, იანგარიშეთ კონტეინერში მოთავსებული ელემენტების საშუალო არითმეთიკული და დაბეჭდეთ იგი. დაბეჭდეთ კონტეინერის უმცირესი და მისი მომდევნო ელემენტები.
```
hello
```
### 5) მოცემულია მთელი არაუარყოფითი რიცხვების ვექტორი {0, 4, 1, 2, 3, 0, 5, 2} დაახარისხეთ იგი გადათვლის (counting sort) ალგორითმით და აჩვენეთ ბიჯების მიხედვით როგორ იცვლება დამხმარე c ვექტორი და საბოლოო b(n) ვექტორი.
```
hello
```
### 6) გროვაში ახალი ელემენტის დამატების, გროვიდან ელემენტის ამოღების და გროვით დახარისხების ალგორითმები. მათი სისწრაფის შეფასება.
```
hello
```
### 7) ძებნის ორობითი ხე. ახალი კვანძის ჩამატების ალგორითმი. მისი კორექტულობისა და სისწრაფის საკითხი. მოიყვანეთ ალგორითმის სახე, რომელსაც ის მიიღებს ძებნის დალაგებული ხის შემთხვევაში.
```
hello
```

